[TOC]



# 2 算法的复杂度分析

## 2.1 算法效率评估

一般来说，在算法设计中，我们追求两个层次的目标：

1. **找到问题的解法**：算法需要在规定的范围的输入范围内可靠的求得问题的正确解
2. **寻求最优解法**：同一种问题可能有多种解法，需要寻找最高效的解法

算法效率成为了评判算法优劣的主要指标，它包括一下两个维度：

- **时间效率**：算法运行时间的长短
- **空间效率**：算法占用内存空间的大小

效率评估的方法主要分两种：实际测试、理论估算

### 2.1.1 实际测试

假如现在有算法`A`和算法`B`，它们都能解决同一问题，但如果要对比两个算法的效率，最直接的方法是找一台计算机去运行两个算法，记录它们各自的运行时间和内存使用情况。这种方式最直观，但局限性很大。

一方面，**难以排除测试环境的干扰因素**。硬件配置会影响算法的性能表现。比如一个算法的并行度较高，那么它就更适合在多核 CPU 上运行，一个算法的内存操作密集，那么它在高性能内存上的表现就会更好。也就是说，算法在不同的机器上的测试结果可能是不一致的。这意味着我们需要在各种机器上进行测试，统计平均效率，而这是不现实的。

另一方面，**展开完整测试非常耗费资源**。随着输入数据量的变化，算法会表现出不同的效率。例如，在输入数据量较小时，算法 `A` 的运行时间比算法 `B` 短；而在输入数据量较大时，测试结果可能恰恰相反。因此，为了得到有说服力的结论，我们需要测试各种规模的输入数据，而这需要耗费大量的计算资源。

### 2.1.2 理论估算

可以通过一些方法来计算评估算法的效率。这种估算方法被称为渐进复杂度分析（asymptotic complexity analysis），简称复杂度分析。

复杂度分析可以体现算法运行所需时间和空间资源（内存空间）与输入数据大小的关系。它可以描述随着输入数据的大小的增加，算法执行所需时间和空间增长的趋势。

复杂度分为两种评判方式：

- **时间复杂度**
- **空间复杂度**

复杂度分析克服实际测试方法的弊端体现在一下几个方面：

- 独立于测试环境，分析结果具有普遍性
- 可以体现不同数据量下的算法效率，尤其是大数据量下的算法性能

## 2.2 迭代与递归

### 2.2.1 迭代

迭代（iteration）是一种重复执行某个任务的控制结构。在迭代中，程序会在满足一定的条件下重复执行某段代码，直到这个条件不再满足。

迭代有`for`循环、`while`循环和嵌套循环（一个循环机构里嵌套另一个循环）。

### 2.2.2 递归

递归（recursion）是一种算法策略，通过函数调用自身来解决问题，它主要包括两个阶段：

1. **递**：程序不断深入地调用自身，然后达到“终止条件”
2. **归**：触发终止条件后，程序有最深层的递归函数开始逐层返回，汇聚每一层的结果

故递归代码主要包含一下三个要素：

1. **终止条件**：决定什么时候程序开始从深层返回
2. **递归调用**：函数调用自身，通常输入更小或更简化的参数
3. **返回结果**：由当前递归层级返回到上一层

以下代码中函数可以完成`1+2+3+...+n`的计算。

```c++
int recursion(int n)
{
	//终止条件
	if(n==1)
	{
		return 1;
	}
	//递归调用
	int res = recursion(n-1);
	//返回结果
	return n + res;
}
```

![img](https://cdn.jsdelivr.net/gh/ctyhail/image_bed@master/image/recursion_sum.png)

其实可以发现，迭代算法和递归都能解决这个问题，但递归是劣于迭代的。

#### 2.2.2.1 调用栈

递归函数每次调用自身时，系统都会新开启的函数分配内存，以储存变量、调用地址和其他信息。这会有以下两个缺点：

- 函数的数据都存储在被称为“栈帧空间”的内存区域内，知道函数返回才被释放。因此，递归消耗大量的内存空间
- 递归调用函数会产生额外的开销，因此递归的时间效率也很低

在实际中，编程语言允许的递归深度是有限的，过深的递归会导致栈溢出错误。

#### 2.2.2.2 尾递归

如果函数在返回前的最后一步才进行分递归调用，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当。这种情况被称为“尾递归”（tail recursion)。

- **普通递归**：当函数返回到上一层级的函数后，需要继续执行代码，因此系统需要保存上一层调用的上下文。
- **尾递归**：递归调用是函数返回前的最后一个操作，这意味着函数返回到上一层级后，无须继续执行其他操作，因此系统无须保存上一层函数的上下文。

还是以`1+2+3+...+n`举例，将变量`res`设为函数参数，从而实现尾递归：（res初始值为0）

```c++
int tailRecur(int n, int res) 
{
    // 终止条件
    if (n == 0)
        return res;
    // 尾递归调用
    return tailRecur(n - 1, res + n);
}
```

![尾递归过程](https://cdn.jsdelivr.net/gh/ctyhail/image_bed@master/image/tail_recursion_sum.png)

**注意**：许多编译器或解释器并不支持尾递归优化。例如，Python 默认不支持尾递归优化，因此即使函数是尾递归形式，仍然可能会遇到栈溢出问题。

#### 2.2.2.3 递归树

斐波那契数列：0,1,1,2,3,5,8,...。设斐波那契数列中的第n个数字为`f(n)`，可以得出两个结论：

- 数列的前两个数字为`f(1)=0`和`f(2)=1`
- 数列中每个数字是前两个数字的和，即`f(n)=f(n-1)+f(n-2)`

可以根据以上条件写出递归求解斐波那契数列中第n个数字：

```c++
int fib(int n)
{
    //终止条件
	if(n==1) return 0;
	if(n==2) return 1;
	//递归调用
	int res = fib(n-1)+fib(n-2);
	//返回结果
	return res;
}
```

在上面的代码中，我们在函数内递归调用了两个函数，这意味着从一个调用产生了两个调用分支。这用不断递归调用下去，最终会产生一颗层数为n的**递归树**（recursion tree)。

![斐波那契数列的递归树](https://cdn.jsdelivr.net/gh/ctyhail/image_bed@master/image/recursion_tree.png)

递归的思维本质是：将问题分解为更小子问题。这种分治策略很重要。

- 从算法角度看，搜索、排序、回溯、分治、动态规划等许多重要算法策略直接或间接地应用了这种思维方式。
- 从数据结构角度看，递归天然适合处理链表、树和图的相关问题，因为它们非常适合用分治思想进行分析。

### 2.2.3 二者对比

|          | 迭代                                   | 递归                                                         |
| :------- | :------------------------------------- | :----------------------------------------------------------- |
| 实现方式 | 循环结构                               | 函数调用自身                                                 |
| 时间效率 | 效率通常较高，无函数调用开销           | 每次函数调用都会产生开销                                     |
| 内存使用 | 通常使用固定大小的内存空间             | 累积函数调用可能使用大量的栈帧空间                           |
| 适用问题 | 适用于简单循环任务，代码直观、可读性好 | 适用于子问题分解，如树、图、分治、回溯等，代码结构简洁、清晰 |

以上述递归函数举例，求和操作在递归的“归”阶段进行。这意味着最初被调用的函数实际上是最后才完成求和操作的，这种机制与栈的“先入后出”原则异曲同工。

事实上，“调用栈”和“栈帧空间”这类递归属于也暗示了递归与栈之间的密切关系。

1. **递**：当函数被调用时，系统会在“调用帧”上为新函数分配新的栈帧，用于储存函数的局部变量、参数、返回地址等数据。
2. **归**：当函数完成执行并返回时，对应的栈帧会从“调用栈”上移除，恢复函数之前的执行环境。

我们可以用一个显示的栈来模拟栈的行为，将递归转化为迭代形式：

```c++
int forLoopRecur(int n) {
    // 使用一个显式的栈来模拟系统调用栈
    stack<int> stack;
    int res = 0;
    // 递：递归调用
    for (int i = n; i > 0; i--) {
        // 通过“入栈操作”模拟“递”
        stack.push(i);
    }
    // 归：返回结果
    while (!stack.empty()) {
        // 通过“出栈操作”模拟“归”
        res += stack.top();
        stack.pop();
    }
    // res = 1+2+3+...+n
    return res;
}
```

迭代和递归在大多数情况下可以相互转化，但还是要根据问题的性质对症下药。

## 2.3 时间复杂度

运行时间可以很直观地反映算法的效率，但是逐语句去计算算法的运行时间不太现实，我们也不希望预估的时间与平台绑定。

### 2.3.1 统计时间增长趋势

**时间复杂度分析统计的不是算法运行的时间**，而是算法运行时间随着数据量变大时增长趋势。给定三个算法`A`、`B`、`C`。

```c++
// 算法 A 的时间复杂度：常数阶
void algorithm_A(int n) {
    cout << 0 << endl;
}
// 算法 B 的时间复杂度：线性阶
void algorithm_B(int n) {
    for (int i = 0; i < n; i++) {
        cout << 0 << endl;
    }
}
// 算法 C 的时间复杂度：常数阶
void algorithm_C(int n) {
    for (int i = 0; i < 1000000; i++) {
        cout << 0 << endl;
    }
```

![算法 A、B 和 C 的时间增长趋势](https://cdn.jsdelivr.net/gh/ctyhail/image_bed@master/image/time_complexity_simple_example.png)

相较于直接统计算法的运行时间，时间复杂度分析有哪些特点呢？

- **时间复杂度能够有效评估算法效率**。例如，算法 `B` 的运行时间呈线性增长，在 n>1 时比算法 `A` 更慢，在 n>1000000 时比算法 `C` 更慢。事实上，只要输入数据大小 n 足够大，复杂度为“常数阶”的算法一定优于“线性阶”的算法，这正是时间增长趋势的含义。
- **时间复杂度的推算方法更简便**。显然，运行平台和计算操作类型都与算法运行时间的增长趋势无关。因此在时间复杂度分析中，我们可以简单地将所有计算操作的执行时间视为相同的“单位时间”，从而将“计算操作运行时间统计”简化为“计算操作数量统计”，这样一来估算难度就大大降低了。
- **时间复杂度也存在一定的局限性**。例如，尽管算法 `A` 和 `C` 的时间复杂度相同，但实际运行时间差别很大。同样，尽管算法 `B` 的时间复杂度比 `C` 高，但在输入数据大小 n 较小时，算法 `B` 明显优于算法 `C` 。对于此类情况，我们时常难以仅凭时间复杂度判断算法效率的高低。当然，尽管存在上述问题，复杂度分析仍然是评判算法效率最有效且常用的方法。

### 2.3.2 函数渐进上界

 给定一个输入大小为$n$的函数：

```c++
void algorithm(int n) {
    int a = 1;  // +1
    a = a + 1;  // +1
    a = a * 2;  // +1
    // 循环 n 次
    for (int i = 0; i < n; i++) { // +1（每轮都执行 i ++）
        cout << 0 << endl;    // +1
    }
}
```

设算法操作数量是关于输入数据的大小的$n$的函数，记为$T(n)$，则
$$
T(n)=2n+3
$$

$T(n)$是一次函数，说明其运行时间的增长趋势是线性的，因此它的时间复杂度是线性阶。

我们将线性阶的时间复杂度记为$O(n)$，这个数学符号称为大$O$记号（big-$O$ notation），表示函数$T(n) $的渐近上界（asymptotic upper bound）。时间复杂度分析本质上是计算“操作数量 T(n)”的渐近上界，它具有明确的数学定义。

| 若存在正实数$c$和实数$n_0$ ，使得对于所有的$n>n_0$ ，均有$T(n)≤c⋅f(n)$ ，则可认为$f(n)$给出了$T(n)$的一个渐近上界，记为$T(n)=O(f(n))$ 。 |
| ------------------------------------------------------------ |

### 2.3.3 推算方法

根据定义，确定$f(n)$之后，我们就可以得到$O(f(n))$。确定渐进上界的方法总体分为两步：首先统计操作数量，然后判断渐进上界。

#### 1 统计操作数量

根据代码，逐行从上到下计算就行。但由于$c⋅f(n)$中$c$可以去任意大小，因此$T(n)$中的各种系数和常数项都可以忽略。同时循环嵌套使用乘法，<u>总操作数量等于外层循环和内层循环操作数量之积</u>。

#### 2 判断渐进上界

<u>时间复杂度由$T(n)$中最高阶的项来决定</u>，当$n$趋于无穷大时，最高阶的项就会发挥主导作用，其余项可以忽略。

如果
$$
T(n)=2n^3+4n^2+7n+89
$$
那么时间复杂度为$O(n^3)$

### 2.3.4 常见类型

设输入数据大小为$n$，常见时间复杂度类型如下图表示：
$$
O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(2^n)<O(n!)
$$

$$
常数阶<对数阶<线性阶<线性对数阶<平方阶<指数阶<阶乘阶
$$

![常见的时间复杂度类型](https://cdn.jsdelivr.net/gh/ctyhail/image_bed@master/image/time_complexity_common_types.png)

这里这讨论笔者不太了解的<u>对数阶、线性对数阶、指数阶和阶乘阶</u>。

#### 对数阶 $O(logn)$

对数阶反映了“每轮都会缩减一部分”的情况。设输入数据大小为 n ，由于每轮缩减到一半，因此循环次数是$log_2⁡n$ ，即$2^n$的反函数。

```c++
int logarithmic(int n) {
    int count = 0;
    while (n > 1) {
        n = n / 2;
        count++;
    }
    return count;
}
```

对数阶也会经常出现在递归函数里。以下代码形成了一颗高度为$log_2n$的递归树：

```c++
int logRecur(int n) {
    if (n <= 1)
        return 0;
    return logRecur(n / 2) + 1;
}
```

对数阶常出现在基于分治策略的算法中，它增长缓慢，是仅次于常数阶的理想时间复杂度。

#### 线性对数阶 $O(nlogn)$

线性对数阶常出现于嵌套循环中，两层循环的时间复杂度分别为$O(logn)$和$O(n)$。

```c++
int linearLogRecur(int n) {
    if (n <= 1)
        return 1;
    int count = linearLogRecur(n / 2) + linearLogRecur(n / 2);
    for (int i = 0; i < n; i++) {
        count++;
    }
    return count;
}
```

下图展示线性对数阶的生成方式，二叉树的每一层的操作总数都为$n$，树共有$log_2n+1$层，因此时间复杂度为$O(nlogn)$

![线性对数阶的时间复杂度](https://cdn.jsdelivr.net/gh/ctyhail/image_bed@master/image/time_complexity_logarithmic_linear.png)

主流排序算法的时间复杂度通常为$O(nlog⁡n)$，例如快速排序、归并排序、堆排序等。

#### 指数阶 $O(2^n)$

时间复杂度呈指数增长。举个例子：一个细胞分裂为两个细胞，然后在分裂成四个细胞，以此类推。下列代码实现了时间复杂度为指数级：。

```c++
int func(int n)
{
	int count = 0 ,base = 1;
	for(int i = 0; i < n; ++i)
	{
		for(int j = 0; j < base; ++j)
		{
			count++;
		}
		base *= 2;
	}
	return count;
}
```

若是base*=3，那么时间复杂度为$O(3^n)$。

![指数阶的时间复杂度](https://cdn.jsdelivr.net/gh/ctyhail/image_bed@master/image/time_complexity_exponential.png)

在实际算法中，指数阶也经常出现在递归函数中，比如求解斐波那契数列第$n$个数。

```c++
int fib(int n)
{
	if(n==1||n==2)
		return n-1;
	return fib(n-1)+bib(n-2);
}
```

指数阶增长<u>非常迅速</u>，在穷举法（暴力搜索、回溯等）中比较常见。对于数据规模较大的问题，指数阶是不可接受的，通常需要使用动态规划或贪心算法等来解决。

#### 阶乘阶 $O(n!)$

阶乘对应数学中的全排列问题。即给定$n$个互不重复的元素，求可能的所有排列方案个数：
$$
n!=n\times(n-1)\times(n-2)\times\cdots\times2\times1
$$
阶乘通常可以用递归使用，比如求解$n!$，给出以下代码：

```C++
int factorialRecur(int n) {
    if (n == 0)
        return 1;
    int count = 0;
    // 从 1 个分裂出 n 个
    for (int i = 0; i < n; i++) {
        count += factorialRecur(n - 1);
    }
    return count;
}
```

这种递归的时间复杂度为$O(n!)$，参照下图

![阶乘阶的时间复杂度](https://cdn.jsdelivr.net/gh/ctyhail/image_bed@master/image/time_complexity_factorial.png)

**当$n\geq4$时，恒有$n!>2^n$。故阶乘阶比指数阶增长地更快，在$n$较大时是不可接受的。

### 2.3.5 总结

算法是运行时间不是固定的，以上计算的时间复杂度是计算的算法最差能达到的情况，但在一些特殊情况下，比如在一个查找算法中，运气好就能一下找到所需要的数据。所以算法`A`时间复杂度比算法`B`高并不一定意味着算法`A`运行时间比算法`B`的运行时间多。、

此外我们还有最佳时间复杂度和平均时间复杂度，但都没有最差时间复杂度（就是我们以上所求的时间复杂度）更为实用。

## 2.4 空间复杂度

空间复杂度（space complexity）用于衡量算法占用内存空间随着数据量变大时增长的趋势。这个概念与时间复杂度非常类似，只需将“运行时间”替换为“占用内存空间”。

### 2.4.1 算法相关空间

算在运行过程中使用的内存空间主要包括以下几种：

- **输入空间**：用于储存算法的输入数据
- **暂存空间**：用于储存算法在运行过程中的变量、对象、函数等数据
- **输出空间**：用于储存算法的输入数据

但一般来说，空间复杂度的统计范围是“暂存空间”加上“输出空间”。

**暂存空间**还可以划分为三部分：

- **暂存数据**：用于保存算法运行过程中的各种常量、变量、对象等。

- **栈帧空间**：用于保存调用函数的上下文数据。系统在每次调用函数时都会在栈顶部创建一个栈帧，<u>函数返回后，栈帧空间会被释放</u>。
- **指令空间**：用于保存编译后的程序指令，在实际统计中通常忽略不计。

分析一段程序的空间复杂度时，**我们通常统计暂存数据、栈帧空间和输出数据三部分**。

![算法使用的相关空间](https://cdn.jsdelivr.net/gh/ctyhail/image_bed@master/image/space_types.png)

```c++
/* 结构体 */
struct Node {
    int val;
    Node *next;
    Node(int x) : val(x), next(nullptr) {}
};

/* 函数 */
int func() {
    // 执行某些操作...
    return 0;
}

int algorithm(int n) {        // 输入数据
    const int a = 0;          // 暂存数据（常量）
    int b = 0;                // 暂存数据（变量）
    Node* node = new Node(0); // 暂存数据（对象）
    int c = func();           // 栈帧空间（调用函数）
    return a + b + c;         // 输出数据
}
```

### 2.4.2 推算方法

空间复杂的推算方法和时间复杂度相似。同时，我们也只关注最差时间空间复杂度。因为内存空间是一个硬性要求，我们要确保在所有输入数据的情况下有足够的空间供程序运行。

“最差”有两个含义：

1. **以最差输入数据为准**：当$n<10$时，空间复杂度为$O(1)$；但当$n>10$时，初始化的数组 `nums` 占用$O(n)$空间，因此最差空间复杂度为$O(n)$。
2. **以算法运行中的峰值内存为准**：例如，程序在执行最后一行之前，占用$O(1)$空间；当初始化数组 `nums` 时，程序占用$O(n)$空间，因此最差空间复杂度为$O(n)$。

### 2.4.3 常见类型

设输入数据大小为$n$，下图展示了常见的空间复杂度类型。


$$
O(1)<O(logn)<O(n)<O(n^2)<O(2^n)
$$

$$
常数阶<对数阶<线性阶<平方阶<指数阶
$$



![常见的空间复杂度类型](https://cdn.jsdelivr.net/gh/ctyhail/image_bed@master/image/space_complexity_common_types.png)

#### 常数阶 $O(1)$

常数阶常见于数量与输入数据大小 n 无关的常量、变量、对象。

需要注意的是，在循环中初始化变量或调用函数而占用的内存，在进入下一循环后就会被释放，因此不会累积占用空间，空间复杂度仍为 O(1) ：

```c++
/* 函数 */
int func() {
    // 执行某些操作
    return 0;
}

/* 常数阶 */
void constant(int n) {
    // 常量、变量、对象占用 O(1) 空间
    const int a = 0;
    int b = 0;
    vector<int> nums(10000);
    ListNode node(0);
    // 循环中的变量占用 O(1) 空间
    for (int i = 0; i < n; i++) {
        int c = 0;
    }
    // 循环中的函数占用 O(1) 空间
    for (int i = 0; i < n; i++) {
        func();
    }
}
```

#### 线性阶 $O(n)$

线性阶常见于<u>元素数量与 n 成正比的数组、链表、栈、队列</u>等：

```c++
/* 线性阶 */
void linear(int n) {
    // 长度为 n 的数组占用 O(n) 空间
    vector<int> nums(n);
    // 长度为 n 的列表占用 O(n) 空间
    vector<ListNode> nodes;
    for (int i = 0; i < n; i++) {
        nodes.push_back(ListNode(i));
    }
    // 长度为 n 的哈希表占用 O(n) 空间
    unordered_map<int, string> map;
    for (int i = 0; i < n; i++) {
        map[i] = to_string(i);
    }
}
```

还有递归函数使用的空间复杂度为$O(n)$栈帧空间：

```c++
/* 线性阶（递归实现） */
void linearRecur(int n) {
    cout << "递归 n = " << n << endl;
    if (n == 1)
        return;
    linearRecur(n - 1);
}
```

#### 平方阶 $O(n^2)$

平方阶常见于矩阵和图，元素数量与$n$成平方关系：

```c++
/* 平方阶 */
void quadratic(int n) {
    // 二维列表占用 O(n^2) 空间
    vector<vector<int>> numMatrix;
    for (int i = 0; i < n; i++) {
        vector<int> tmp;
        for (int j = 0; j < n; j++) {
            tmp.push_back(0);
        }
        numMatrix.push_back(tmp);
    }
}
```

该函数的递归深度为$n$，在每个递归函数中都初始化了一个数组，长度分别为$n、n−1、…、2、1$，平均长度为$n/2$，因此总体占用$O(n^2)$空间：

```c++
/* 平方阶（递归实现） */
int quadraticRecur(int n) {
    if (n <= 0)
        return 0;
    vector<int> nums(n);
    cout << "递归 n = " << n << " 中的 nums 长度 = " << nums.size() << endl;
    return quadraticRecur(n - 1);
}
```

#### 指数阶 $O(2^n)$

指数阶常见于二叉树。观察下图 ，层数为$n$的“满二叉树”的节点数量为$2n−1$，占用$O(2^n)$空间：

```c++
/* 指数阶（建立满二叉树） */
TreeNode *buildTree(int n) {
    if (n == 0)
        return nullptr;
    TreeNode *root = new TreeNode(0);
    root->left = buildTree(n - 1);
    root->right = buildTree(n - 1);
    return root;
}
```

![满二叉树产生的指数阶空间复杂度](https://cdn.jsdelivr.net/gh/ctyhail/image_bed@master/image/space_complexity_exponential.png)

#### 对数阶 $O(logn)$

对数阶常见于分治算法。例如归并排序，输入长度为$n$的数组，每轮递归将数组从中点处划分为两半，形成高度为$log⁡n$的递归树，使用$O(log⁡n)$栈帧空间。

### 2.4.4 总结

一般来说，降低时间复杂度是以提高空间复杂度为代价，反之亦然。这种思路被称为“以空间换时间”。但要根据实际情况将两种复杂度相互转化。





